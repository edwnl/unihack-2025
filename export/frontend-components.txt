# frontend-components Files

### frontend\components\ai-advisor.tsx

```tsx
// frontend/components/ai-advisor.tsx

"use client";

import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import {
  getAIRecommendation,
  ActionRecommendation,
} from "@/lib/ai-advisor-service";
import { GameRoomType, PlayerType } from "@/lib/types";
import {
  Brain,
  Lightbulb,
  TrendingUp,
  ChevronDown,
  ChevronUp,
} from "lucide-react";

interface AIAdvisorProps {
  gameRoom: GameRoomType;
  player: PlayerType;
  isPlayerTurn: boolean;
}

export default function AIAdvisor({ gameRoom, player }: AIAdvisorProps) {
  const [recommendation, setRecommendation] =
    useState<ActionRecommendation | null>(null);
  const [loading, setLoading] = useState(false);
  const [usingMock, setUsingMock] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  // Only show if game is in an active betting state
  const isGameActive = ["PREFLOP", "FLOP", "TURN", "RIVER"].includes(
    gameRoom.gameState,
  );
  if (!isGameActive) {
    return null;
  }

  // Ensure the player has two hole cards before displaying GTO advice
  const hasTwoHoleCards = player.hand?.cards?.length === 2;
  if (!hasTwoHoleCards) {
    return null;
  }

  const handleGetAdvice = async () => {
    setLoading(true);
    setError(null);

    try {
      // Check if API key exists first
      const hasApiKey = !!process.env.NEXT_PUBLIC_OPENAI_API_KEY;
      setUsingMock(!hasApiKey);

      console.log("Getting AI recommendation for player:", player.id);
      const advice = await getAIRecommendation(gameRoom, player.id);
      console.log("Received AI recommendation:", advice);

      setRecommendation(advice);
    } catch (error) {
      console.error("Error getting AI advice:", error);
      setError("Failed to get advice. Please try again.");
    } finally {
      setLoading(false);
    }
  };

  return (
    <Card className="mt-4">
      <CardHeader className="pb-2">
        <CardTitle className="flex items-center gap-2">
          <Brain size={18} />
          <span>Poker Advisor</span>
        </CardTitle>
      </CardHeader>

      <CardContent>
        {error && <p className="text-red-500 text-sm mb-2">{error}</p>}

        {!recommendation ? (
          <div className="flex justify-center">
            <Button
              onClick={handleGetAdvice}
              disabled={loading}
              className="flex items-center gap-2"
            >
              <Lightbulb size={16} />
              <span>{loading ? "Analyzing..." : "Get GTO Advice"}</span>
            </Button>
          </div>
        ) : (
          <AdvisorContent
            recommendation={recommendation}
            setRecommendation={setRecommendation}
            loading={loading}
            handleGetAdvice={handleGetAdvice}
            usingMock={usingMock}
            gameRoom={gameRoom}
          />
        )}
      </CardContent>
    </Card>
  );
}

// Extracted the content into a separate component for clarity
function AdvisorContent({
  recommendation,
  loading,
  handleGetAdvice,
  usingMock,
  gameRoom,
}: {
  recommendation: ActionRecommendation;
  setRecommendation: React.Dispatch<
    React.SetStateAction<ActionRecommendation | null>
  >;
  loading: boolean;
  handleGetAdvice: () => void;
  usingMock: boolean;
  gameRoom: GameRoomType;
}) {
  const [showAdvanced, setShowAdvanced] = useState(false);

  return (
    <div className="space-y-3">
      {/* Main recommendation */}
      <div className="flex items-center gap-2">
        <span className="font-semibold">Recommended:</span>
        <span className="text-lg text-primary">
          {recommendation.action}
          {recommendation.betSize && ` (${recommendation.betSize} chips)`}
        </span>
      </div>

      {/* Explanation */}
      <div className="text-sm text-muted-foreground">
        {recommendation.explanation}
      </div>

      {/* Hand analysis section */}
      <div className="grid grid-cols-2 gap-2 bg-muted/20 rounded-md p-2">
        {recommendation.handStrength && (
          <div className="text-xs">
            <span className="font-semibold">Hand:</span>{" "}
            {recommendation.handStrength}
          </div>
        )}

        {recommendation.equity !== undefined && (
          <div className="text-xs">
            <span className="font-semibold">Equity:</span>{" "}
            {Math.round(recommendation.equity * 100)}%
          </div>
        )}

        {recommendation.drawStrength && (
          <div className="text-xs">
            <span className="font-semibold">Draw:</span>{" "}
            {recommendation.drawStrength}
          </div>
        )}

        {recommendation.outs !== undefined && recommendation.outs > 0 && (
          <div className="text-xs">
            <span className="font-semibold">Outs:</span> {recommendation.outs}
          </div>
        )}
      </div>

      {/* Action probabilities */}
      {recommendation.probabilities && (
        <ActionProbabilities recommendation={recommendation} />
      )}

      {/* Advanced metrics toggle */}
      <Button
        variant="ghost"
        size="sm"
        className="w-full mt-1 text-xs flex items-center justify-center gap-1"
        onClick={() => setShowAdvanced(!showAdvanced)}
      >
        <TrendingUp size={14} />
        <span>
          {showAdvanced ? "Hide Advanced Metrics" : "Show Advanced Metrics"}
        </span>
        {showAdvanced ? <ChevronUp size={14} /> : <ChevronDown size={14} />}
      </Button>

      {/* Advanced poker metrics section */}
      {showAdvanced && (
        <AdvancedMetrics recommendation={recommendation} gameRoom={gameRoom} />
      )}

      {/* Data source indicator */}
      {usingMock && (
        <div className="text-xs text-amber-500 mt-1">
          Using mock recommendations (no API key)
        </div>
      )}

      {/* Ask for new advice */}
      <div className="flex justify-end mt-2">
        <Button
          onClick={handleGetAdvice}
          disabled={loading}
          variant="outline"
          size="sm"
        >
          {loading ? "Analyzing..." : "Refresh Advice"}
        </Button>
      </div>
    </div>
  );
}

function ActionProbabilities({
  recommendation,
}: {
  recommendation: ActionRecommendation;
}) {
  return (
    <div className="mt-2">
      <p className="text-xs font-semibold mb-1">GTO Action Distribution:</p>
      <div className="flex h-4 w-full rounded-md overflow-hidden bg-gray-800">
        {(() => {
          // Normalize probabilities to ensure they sum to 100%
          const probs = { ...recommendation.probabilities };
          const sum = Object.values(probs).reduce(
            (acc, val) => acc + (isNaN(val) ? 0 : val),
            0,
          );

          if (sum > 0 && Math.abs(sum - 1) > 0.01) {
            Object.keys(probs).forEach((key) => {
              // Provide a fallback of 0 if undefined
              const currentVal = probs[key as keyof typeof probs] ?? 0;
              probs[key as keyof typeof probs] = currentVal / sum;
            });
          }

          return Object.entries(probs).map(([action, prob]) => {
            const probability = isNaN(prob) ? 0 : prob;
            if (probability <= 0) return null;

            const colorMap: Record<string, string> = {
              check: "bg-blue-600",
              call: "bg-green-600",
              bet: "bg-yellow-600",
              raise: "bg-orange-600",
              fold: "bg-red-600",
            };

            return (
              <div
                key={action}
                className={`${colorMap[action] || "bg-gray-600"}`}
                style={{ width: `${probability * 100}%` }}
                title={`${action}: ${Math.round(probability * 100)}%`}
              />
            );
          });
        })()}
      </div>
      <div className="flex justify-between text-xs mt-1 text-muted-foreground">
        {(() => {
          // Normalize probabilities again for the text display
          const probs = { ...recommendation.probabilities };
          const sum = Object.values(probs).reduce(
            (acc, val) => acc + (isNaN(val) ? 0 : val),
            0,
          );

          if (sum > 0 && Math.abs(sum - 1) > 0.01) {
            Object.keys(probs).forEach((key) => {
              // Provide a fallback of 0 if undefined
              const currentVal = probs[key as keyof typeof probs] ?? 0;
              probs[key as keyof typeof probs] = currentVal / sum;
            });
          }

          return Object.entries(probs)
            .filter(([, prob]) => !isNaN(prob) && prob > 0)
            .map(([action, prob]) => (
              <div key={action}>
                {action}: {Math.round(prob * 100)}%
              </div>
            ));
        })()}
      </div>
    </div>
  );
}

function AdvancedMetrics({
  recommendation,
  gameRoom,
}: {
  recommendation: ActionRecommendation;
  gameRoom: GameRoomType;
}) {
  return (
    <div className="bg-muted/10 p-2 rounded-md text-xs space-y-2">
      <div className="grid grid-cols-2 gap-x-4 gap-y-2">
        {recommendation.potOdds !== undefined && (
          <div>
            <span className="font-semibold">Pot Odds:</span>{" "}
            {Math.round(recommendation.potOdds * 100)}%
          </div>
        )}

        {recommendation.foldEquity !== undefined && (
          <div>
            <span className="font-semibold">Fold Equity:</span>{" "}
            {Math.round(recommendation.foldEquity * 100)}%
          </div>
        )}

        {recommendation.outs !== undefined && recommendation.outs > 0 && (
          <div>
            <span className="font-semibold">Drawing Odds:</span>{" "}
            {Math.round(
              recommendation.outs *
                (gameRoom.gameState === "TURN" ? 4 : 2) *
                10,
            ) / 10}
            %
          </div>
        )}

        <div>
          <span className="font-semibold">Risk/Reward:</span>{" "}
          {calculateRiskReward(recommendation, gameRoom.pot || 0)}
        </div>
      </div>

      <div className="mt-1">
        <span className="font-semibold">Strategic Insight:</span>{" "}
        {getStrategicInsight(recommendation, gameRoom.gameState)}
      </div>
    </div>
  );
}

// Helper function to calculate risk/reward ratio
function calculateRiskReward(
  recommendation: ActionRecommendation,
  potSize: number,
): string {
  if (recommendation.action === "Fold" || recommendation.action === "Check") {
    return "0:1";
  }

  if (
    recommendation.action === "Call" ||
    recommendation.action === "Bet" ||
    recommendation.action === "Raise"
  ) {
    const risk = recommendation.betSize || 0;
    if (risk === 0) return "0:1";

    const reward = potSize + (recommendation.action === "Call" ? 0 : risk);
    const ratio = Math.round((reward / risk) * 10) / 10;

    return `1:${ratio}`;
  }

  return "N/A";
}

// Generate strategic insight based on recommendation
function getStrategicInsight(
  recommendation: ActionRecommendation,
  gameState: string,
): string {
  if (recommendation.action === "Fold") {
    return "Preserving chips for better opportunities.";
  }

  if (recommendation.action === "Check") {
    return "Controlling pot size while keeping options open.";
  }

  if (recommendation.action === "Call") {
    if (recommendation.outs && recommendation.outs > 7) {
      return "Calling with drawing odds in your favor.";
    }
    return "Keeping opponent's range wide while seeing next card.";
  }

  if (recommendation.action === "Bet") {
    if (gameState === "RIVER") {
      return "Thin value betting to extract maximum chips.";
    }

    if (recommendation.drawStrength) {
      return "Semi-bluffing with both immediate fold equity and drawing potential.";
    }

    if (
      recommendation.handStrength &&
      recommendation.handStrength !== "High Card"
    ) {
      return "Value betting for protection against draws.";
    }

    return "Taking initiative with a continuation bet.";
  }

  if (recommendation.action === "Raise") {
    if (gameState === "RIVER") {
      return "Maximizing value on the final betting round.";
    }

    if (recommendation.drawStrength) {
      return "Building pot for when your draw hits while creating fold equity.";
    }

    if (recommendation.foldEquity && recommendation.foldEquity > 0.5) {
      return "Semi-bluff raising with high fold equity.";
    }

    return "Raising for value and to charge draws correctly.";
  }

  return "Balanced play following GTO principles.";
}

```


### frontend\components\community-cards.tsx

```tsx
// frontend/components/community-cards.tsx
"use client";

import PlayingCard from "@/components/playing-card";
import { CardType, GameRoomType } from "@/lib/types";

interface CommunityCardsProps {
  gameRoom: GameRoomType;
}

export default function CommunityCards({ gameRoom }: CommunityCardsProps) {
  // Fill with placeholders if less than 5 cards
  const displayCards = [...(gameRoom.communityCards || [])];
  while (displayCards.length < 5) {
    displayCards.push(null as unknown as CardType);
  }

  if (!gameRoom) {
    return null;
  }

  return (
    <div className="border border-dashed rounded-md p-4 my-4">
      <div className="flex items-center justify-between mb-4">
        <div>
          <span className="text-sm font-normal bg-secondary px-3 py-1 rounded">
            {gameRoom.waitingForCards ? "DEALING" : gameRoom.gameState}
          </span>
        </div>
        <p className="text-center">Community Cards</p>

        <div className="flex space-x-2">
          <span className="text-sm font-normal bg-secondary px-3 py-1 rounded">
            Pot: {gameRoom.pot}
          </span>
        </div>
      </div>

      <div className="flex justify-center gap-2 flex-wrap">
        {displayCards.map((card, index) => (
          <PlayingCard key={index} card={card} hidden={!card} />
        ))}
      </div>
    </div>
  );
}

```


### frontend\components\dealer-view.tsx

```tsx
// frontend/components/dealer-view.tsx
"use client";

import { useState } from "react";
import { useGameContext } from "@/lib/game-context";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { sendGameAction } from "@/lib/websocket-service";
import CommunityCards from "@/components/community-cards";
import PlayerHand from "@/components/player-hand";
import GameActions from "@/components/game-actions";
import { getPokerPosition } from "@/lib/utils";
import { Input } from "./ui/input";
import { useAzureSpeechRecognition } from "@/hooks/useAzureSpeechRecognition";
import { Mic, MicOff } from "lucide-react";
import { findBestPokerActionMatch, extractNumber } from "@/lib/fuzzy-match";

interface DealerViewProps {
  gameId: string;
}

// Helper function to calculate how many cards remain to be scanned
/* eslint-disable @typescript-eslint/no-explicit-any */
function getRemainingCards(gameRoom: any): number {
  let remaining = 0;
  const currentCommunity = gameRoom.communityCards
    ? gameRoom.communityCards.length
    : 0;

  if (gameRoom.gameState === "PREFLOP") {
    // For PREFLOP, every active player should have 2 cards.
    /* eslint-disable @typescript-eslint/no-explicit-any */
    const activePlayers = gameRoom.players.filter((p: any) => p.active).length;
    const totalRequired = activePlayers * 2;
    let currentDealt = 0;

    /* eslint-disable @typescript-eslint/no-explicit-any */
    gameRoom.players.forEach((p: any) => {
      if (p.hand && p.hand.cards) {
        currentDealt += p.hand.cards.length;
      }
    });
    remaining = totalRequired - currentDealt;
  } else if (gameRoom.gameState === "FLOP") {
    // The FLOP needs exactly 3 community cards
    remaining = 3 - currentCommunity;
  } else if (gameRoom.gameState === "TURN") {
    // After the flop, the TURN is the 4th community card
    remaining = 4 - currentCommunity;
  } else if (gameRoom.gameState === "RIVER") {
    // The RIVER is the 5th community card
    remaining = 5 - currentCommunity;
  }

  // Make sure we never return a negative number
  return remaining < 0 ? 0 : remaining;
}

export default function DealerView({ gameId }: DealerViewProps) {
  const { gameRoom } = useGameContext();
  const [error, setError] = useState<string | null>(null);
  const [errorMsg, setErrorMsg] = useState<string>("");
  const [raiseInput, setRaiseInput] = useState<number>(0);
  const [cardsSeen, setCardsSeen] = useState(new Set<string>());

  // Use Azure speech recognition hook
  const {
    isListening,
    recognizedText,
    startListening,
    stopListening,
    clearRecognizedText,
  } = useAzureSpeechRecognition((transcript) => {
    handleVoiceCommand(transcript);
    // Clear recognized text after 3 seconds
    setTimeout(() => clearRecognizedText(), 3000);
  });

  // Early return if gameRoom is not yet loaded
  if (!gameRoom) return <p>Loading dealer view...</p>;

  // Detect if the game is finished (SHOWDOWN or ENDED)
  const isGameOver =
    gameRoom.gameState === "SHOWDOWN" || gameRoom.gameState === "ENDED";

  // Determine current player from gameRoom using currentPlayerIndex
  const currentPlayer = gameRoom.players[gameRoom.currentPlayerIndex];

  // Recalculate call amount from current player's bet (from gameRoom.bets)
  const getCallAmount = () => {
    if (!currentPlayer) return 0;
    const currentPlayerBet =
      (gameRoom.bets && gameRoom.bets[currentPlayer.id]) || 0;
    if (!gameRoom.currentBet) return 0;
    return gameRoom.currentBet - currentPlayerBet;
  };

  // Calculate how many cards remain to be scanned
  const remainingCards = getRemainingCards(gameRoom);
  // Allow scanning only if the game is waiting for cards, there are cards remaining, and the game is not over.
  const canScan = gameRoom.waitingForCards && remainingCards > 0 && !isGameOver;

  // Manual actions are disabled if the game is still waiting for cards or if the current player has folded.
  const actionsDisabled = gameRoom.waitingForCards || currentPlayer?.folded;

  // Handler for scanning a card
  const handleScanCard = () => {
    if (!canScan) return; // Prevent scanning if not allowed

    const suits = ["HEARTS", "DIAMONDS", "CLUBS", "SPADES"];
    const ranks = [
      "TWO",
      "THREE",
      "FOUR",
      "FIVE",
      "SIX",
      "SEVEN",
      "EIGHT",
      "NINE",
      "TEN",
      "JACK",
      "QUEEN",
      "KING",
      "ACE",
    ];
    const randomSuit = suits[Math.floor(Math.random() * suits.length)];
    const randomRank = ranks[Math.floor(Math.random() * ranks.length)];

    // Avoid scanning the same card twice
    if (cardsSeen.has(`${randomSuit}-${randomRank}`)) {
      return handleScanCard();
    } else {
      setCardsSeen(new Set(cardsSeen.add(`${randomSuit}-${randomRank}`)));
    }

    sendGameAction(gameId, {
      type: "SCAN_CARD",
      card: {
        suit: randomSuit,
        rank: randomRank,
      },
    });
  };

  // Handler for starting a new hand
  const handleStartNewHand = async () => {
    setCardsSeen(new Set<string>());
    try {
      const backendUrl =
        process.env.NEXT_PUBLIC_BACKEND_URL || "http://localhost:8080";
      const response = await fetch(
        `${backendUrl}/api/game/${gameId}/new-hand`,
        {
          method: "POST",
        },
      );
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(errorText || "Failed to start new hand");
      }
    } catch (err) {
      setError((err as Error).message);
    }
  };

  // Voice command handling
  const handleVoiceCommand = (command: string) => {
    // If the game is over, ignore voice commands
    if (isGameOver) return;

    // Clean up the command - remove punctuation and normalize
    const normalized = command
      .toLowerCase()
      .trim()
      .replace(/[.,!?;:]/g, "");

    console.log("Dealer processing voice command:", normalized);

    if (currentPlayer.folded) {
      setErrorMsg("Player has already folded.");
      return;
    }
    const callAmt = getCallAmount();

    // Check for player-specific commands format: "player [action]"
    const isPlayerCommand =
      normalized.startsWith("player") || normalized.startsWith("layer");

    if (isPlayerCommand) {
      // Extract the action part after "player "
      const actionPart = normalized.replace(/^(player|layer)\s+/i, "");

      // Use fuzzy matching to identify the action
      const action = findBestPokerActionMatch(actionPart);

      if (!action) {
        setErrorMsg(
          "Unrecognized action. Try again with fold, check, call, raise, bet, or all-in.",
        );
        return;
      }

      // Handle different actions
      if (action === "fold") {
        sendGameAction(gameId, {
          playerId: currentPlayer.id,
          playerName: currentPlayer.name,
          type: "FOLD",
        });
      } else if (action === "check") {
        if (callAmt > 0) {
          setErrorMsg(
            "Cannot check when there's a bet to call. Did you mean 'call'?",
          );
          return;
        }
        sendGameAction(gameId, {
          playerId: currentPlayer.id,
          playerName: currentPlayer.name,
          type: "CHECK",
        });
      } else if (action === "call") {
        if (callAmt === 0) {
          setErrorMsg(
            "Call amount is zero. Please say 'player check' instead.",
          );
          return;
        }
        sendGameAction(gameId, {
          playerId: currentPlayer.id,
          playerName: currentPlayer.name,
          type: "CALL",
          amount: callAmt,
        });
      } else if (action === "raise" || action === "bet") {
        // Extract the amount from the original command
        const amount = extractNumber(actionPart);

        if (!amount) {
          setErrorMsg(
            `No amount specified for ${action}. Please say '${action} [amount]'.`,
          );
          return;
        }

        if (amount <= 0) {
          setErrorMsg(`${action} amount must be positive.`);
          return;
        }

        if (amount + callAmt > currentPlayer.chips) {
          setErrorMsg(`${action} amount exceeds player's chips.`);
          return;
        }

        setErrorMsg("");
        sendGameAction(gameId, {
          playerId: currentPlayer.id,
          playerName: currentPlayer.name,
          type: action.toUpperCase() === "BET" ? "BET" : "RAISE",
          amount: amount,
        });
      } else if (action === "allin") {
        // Handle all-in as a special case
        const allInAmount = currentPlayer.chips;
        sendGameAction(gameId, {
          playerId: currentPlayer.id,
          playerName: currentPlayer.name,
          type: callAmt > 0 ? "RAISE" : "BET",
          amount: allInAmount,
        });
      }
      return;
    }

    // Process direct action commands without the "player" prefix
    const action = findBestPokerActionMatch(normalized);

    if (!action) {
      console.log("Unrecognized voice command:", normalized);
      return;
    }

    if (action === "fold") {
      sendGameAction(gameId, {
        playerId: currentPlayer.id,
        playerName: currentPlayer.name,
        type: "FOLD",
      });
    } else if (action === "check") {
      if (callAmt > 0) {
        setErrorMsg(
          "Cannot check when there's a bet to call. Did you mean 'call'?",
        );
        return;
      }
      sendGameAction(gameId, {
        playerId: currentPlayer.id,
        playerName: currentPlayer.name,
        type: "CHECK",
      });
    } else if (action === "call") {
      if (callAmt === 0) {
        setErrorMsg("Call amount is zero. Please say 'check' instead.");
        return;
      }
      sendGameAction(gameId, {
        playerId: currentPlayer.id,
        playerName: currentPlayer.name,
        type: "CALL",
        amount: callAmt,
      });
    } else if (action === "raise" || action === "bet") {
      // Extract the amount from the command
      const amount = extractNumber(normalized);

      if (!amount) {
        setErrorMsg(
          `No amount specified for ${action}. Please say '${action} [amount]'.`,
        );
        return;
      }

      if (amount <= 0) {
        setErrorMsg(`${action} amount must be positive.`);
        return;
      }

      if (amount + callAmt > currentPlayer.chips) {
        setErrorMsg(`${action} amount exceeds player's chips.`);
        return;
      }

      setErrorMsg("");
      sendGameAction(gameId, {
        playerId: currentPlayer.id,
        playerName: currentPlayer.name,
        type: action.toUpperCase() === "BET" ? "BET" : "RAISE",
        amount: amount,
      });
    } else if (action === "allin") {
      // Handle all-in
      const allInAmount = currentPlayer.chips;
      sendGameAction(gameId, {
        playerId: currentPlayer.id,
        playerName: currentPlayer.name,
        type: callAmt > 0 ? "RAISE" : "BET",
        amount: allInAmount,
      });
    } else {
      console.log("Unrecognized action:", action);
    }
  };

  // Manual action handlers
  const handleManualFold = () => {
    if (isGameOver) return;
    sendGameAction(gameId, {
      playerId: currentPlayer.id,
      playerName: currentPlayer.name,
      type: "FOLD",
    });
  };
  const handleManualCheck = () => {
    if (isGameOver) return;
    const callAmt = getCallAmount();
    if (callAmt > 0) {
      setErrorMsg("Cannot check when there's a bet to call. Please use Call.");
      return;
    }
    setErrorMsg("");
    sendGameAction(gameId, {
      playerId: currentPlayer.id,
      playerName: currentPlayer.name,
      type: "CHECK",
    });
  };
  const handleManualCall = () => {
    if (isGameOver) return;
    const callAmt = getCallAmount();
    if (callAmt === 0) {
      setErrorMsg("Call amount is zero. Please use Check.");
      return;
    }
    sendGameAction(gameId, {
      playerId: currentPlayer.id,
      playerName: currentPlayer.name,
      type: "CALL",
      amount: callAmt,
    });
  };
  const handleManualRaise = () => {
    if (isGameOver) return;
    if (raiseInput <= 0) {
      setErrorMsg("Raise amount must be positive.");
      return;
    }
    if (raiseInput + getCallAmount() > (currentPlayer?.chips || 0)) {
      setErrorMsg("Raise amount exceeds player's chips.");
      return;
    }
    setErrorMsg("");
    sendGameAction(gameId, {
      playerId: currentPlayer.id,
      playerName: currentPlayer.name,
      type: "RAISE",
      amount: raiseInput,
    });
  };
  const handleManualAllIn = () => {
    if (!currentPlayer) return;
    const allInAmount = currentPlayer.chips;
    if (allInAmount <= 0) {
      setErrorMsg("Player has no chips to go all in with.");
      return;
    }
    setErrorMsg("");
    sendGameAction(gameId, {
      playerId: currentPlayer.id,
      playerName: currentPlayer.name,
      type: getCallAmount() > 0 ? "RAISE" : "BET",
      amount: allInAmount,
    });
  };

  const toggleListening = () => {
    if (isListening) {
      stopListening();
    } else {
      startListening();
    }
  };

  return (
    <div className="w-full max-w-4xl">
      <Card className="mb-6">
        <CardHeader>
          <CardTitle className="flex flex-col items-center">
            <div className="w-full flex justify-between items-center">
              <span>Game Room: {gameId}</span>
              <div className="flex space-x-2 items-center">
                <span className="text-sm font-normal bg-secondary px-3 py-1 rounded">
                  {gameRoom.gameState}
                </span>
                <span className="text-sm font-normal bg-secondary px-3 py-1 rounded">
                  Pot: {gameRoom.pot}
                </span>
              </div>
            </div>
            <div className="mt-2 flex justify-center">
              <Button
                onClick={toggleListening}
                className={`px-3 py-1 ${isListening ? "bg-red-500" : ""}`}
              >
                {isListening ? (
                  <div className="flex items-center">
                    <MicOff className="h-4 w-4 mr-1" />
                    Stop Listening
                  </div>
                ) : (
                  <div className="flex items-center">
                    <Mic className="h-4 w-4 mr-1" />
                    Start Listening
                  </div>
                )}
              </Button>
            </div>
          </CardTitle>
        </CardHeader>
        <CardContent>
          <div className="flex flex-col space-y-4">
            <div>
              <h3 className="text-lg font-medium mb-2">
                Players ({gameRoom.players.length}/5):
              </h3>
              <div className="grid grid-cols-1 md:grid-cols-3 lg:grid-cols-5 gap-4 overflow-x-auto whitespace-nowrap">
                {gameRoom.players.map((player, index) => {
                  const position = getPokerPosition(
                    index,
                    gameRoom.players.length,
                    gameRoom.smallBlindPosition,
                  );
                  const isWinner =
                    gameRoom.winnerIds &&
                    gameRoom.winnerIds.includes(player.id);
                  return (
                    <PlayerHand
                      key={player.id}
                      player={player}
                      isCurrentPlayer={
                        gameRoom.currentPlayerIndex === index &&
                        gameRoom.gameState !== "SHOWDOWN" &&
                        gameRoom.gameState !== "ENDED"
                      }
                      position={position}
                      isWinner={isWinner}
                      showCards={true}
                    />
                  );
                })}
              </div>
            </div>

            <CommunityCards gameRoom={gameRoom} />

            {/* Scan Card Button with Countdown */}
            <Button
              onClick={handleScanCard}
              className="w-full"
              disabled={!canScan}
            >
              Scan Random Card ({remainingCards} remaining)
            </Button>

            {/* Manual Action Panel for current player */}
            <div className="p-4 border rounded-md">
              <p className="text-sm font-medium mb-2">
                Current Action for: {currentPlayer?.name}
              </p>
              <div className="flex justify-between items-center mb-2 text-sm">
                <span>Call Amount: {getCallAmount()}</span>
                <span>Chips: {currentPlayer?.chips}</span>
              </div>
              <div className="flex items-center gap-2">
                <Button
                  disabled={actionsDisabled}
                  onClick={handleManualFold}
                  variant="secondary"
                >
                  Fold
                </Button>
                {getCallAmount() === 0 ? (
                  <Button
                    disabled={actionsDisabled}
                    onClick={handleManualCheck}
                  >
                    Check
                  </Button>
                ) : (
                  <Button
                    onClick={handleManualCall}
                    disabled={
                      getCallAmount() > (currentPlayer?.chips || 0) ||
                      actionsDisabled
                    }
                  >
                    Call ({getCallAmount()})
                  </Button>
                )}
                <Input
                  type="number"
                  min={1}
                  max={Math.max(
                    0,
                    (currentPlayer?.chips || 0) - getCallAmount(),
                  )}
                  value={raiseInput.toString()}
                  onChange={(e) => setRaiseInput(Number(e.target.value))}
                  className="w-16"
                  disabled={actionsDisabled}
                />
                <Button
                  onClick={handleManualRaise}
                  disabled={
                    raiseInput <= 0 ||
                    raiseInput + getCallAmount() >
                      (currentPlayer?.chips || 0) ||
                    actionsDisabled
                  }
                >
                  Raise
                </Button>
                <Button
                  onClick={handleManualAllIn}
                  disabled={(currentPlayer?.chips || 0) <= 0 || actionsDisabled}
                  className="bg-red-600 hover:bg-red-700"
                >
                  All In
                </Button>
              </div>
            </div>

            {(gameRoom.gameState === "SHOWDOWN" ||
              gameRoom.gameState === "ENDED") && (
              <Button onClick={handleStartNewHand} className="w-full">
                Start New Hand
              </Button>
            )}

            {error && <p className="text-red-500 text-center mt-4">{error}</p>}
            {recognizedText && (
              <p className="mt-2 text-sm text-center text-muted-foreground">
                Recognized: {recognizedText}
              </p>
            )}
            {errorMsg && (
              <p className="mt-2 text-sm text-center text-red-500">
                {errorMsg}
              </p>
            )}
          </div>
        </CardContent>
      </Card>

      <GameActions actions={gameRoom.actions || []} />
    </div>
  );
}

```


### frontend\components\debug-navigation.tsx

```tsx
// frontend/components/debug-navigation.tsx
"use client";

import { useRouter } from "next/navigation";
import { User, Users } from "lucide-react";

export default function DebugNavigation() {
  const router = useRouter();

  return (
    <div className="fixed top-2 left-2 z-50 flex gap-2 bg-black/30 backdrop-blur-sm p-1 rounded-md">
      <button
        onClick={() => router.push("/poker/dealer")}
        className="text-xs p-1 hover:bg-gray-700 rounded-md"
        title="Go to dealer start"
      >
        <Users size={32} />
      </button>
      <button
        onClick={() => router.push("/poker/player")}
        className="text-xs p-1 hover:bg-gray-700 rounded-md"
        title="Go to player start"
      >
        <User size={32} />
      </button>
    </div>
  );
}

```


### frontend\components\game-actions.tsx

```tsx
// frontend/components/game-actions.tsx
"use client";

import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { GameActionType } from "@/lib/types";
import { useEffect, useRef } from "react";

interface GameActionsProps {
  actions: GameActionType[];
}

export default function GameActions({ actions = [] }: GameActionsProps) {
  // Reference to the content div for scrolling
  const contentRef = useRef<HTMLDivElement>(null);

  // Auto-scroll to the bottom when new actions come in
  useEffect(() => {
    if (contentRef.current) {
      contentRef.current.scrollTop = contentRef.current.scrollHeight;
    }
  }, [actions]);

  // Sort actions chronologically
  const sortedActions = [...actions].sort((a, b) => {
    if (!a.timestamp && !b.timestamp) return 0;
    if (!a.timestamp) return -1;
    if (!b.timestamp) return 1;
    return new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime();
  });

  const formatAction = (action: GameActionType) => {
    switch (action.type) {
      case "JOIN":
        return `${action.playerName} joined the game`;
      case "LEAVE":
        return `${action.playerName} left the game`;
      case "CHECK":
        return `${action.playerName} checks`;
      case "BET":
        return `${action.playerName} bets ${action.amount} chips`;
      case "CALL":
        return `${action.playerName} calls ${action.amount} chips`;
      case "RAISE":
        return `${action.playerName} raises ${action.amount} chips`;
      case "FOLD":
        return `${action.playerName} folds`;
      case "SCAN_CARD":
        return `Card scanned: ${action.card?.rank} of ${action.card?.suit}`;
      case "DEAL_CARDS":
        return `Cards are being dealt`;
      case "START_HAND":
        return `New hand started`;
      case "SMALL_BLIND":
        return `${action.playerName} posts small blind of ${action.amount}`;
      case "BIG_BLIND":
        return `${action.playerName} posts big blind of ${action.amount}`;
      case "LOG":
        return `${action.message || "Game log message"}`;
      default:
        return `Unknown action: ${action.type}`;
    }
  };

  const formatTime = (timestamp: string) => {
    if (!timestamp) return "";
    const date = new Date(timestamp);
    return date.toLocaleTimeString([], {
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
    });
  };

  return (
    <Card>
      <CardHeader className="pb-2">
        <CardTitle className="flex justify-between items-center">
          <span>Game Actions</span>
          <span className="text-xs text-muted-foreground">
            {sortedActions.length} actions
          </span>
        </CardTitle>
      </CardHeader>
      <CardContent
        className="max-h-80 overflow-y-auto px-4 py-2"
        ref={contentRef}
      >
        {sortedActions.length === 0 ? (
          <p className="text-center text-muted-foreground">No actions yet</p>
        ) : (
          <ul className="space-y-1 text-sm">
            {sortedActions.map((action, index) => (
              <li
                key={index}
                className={`pb-1 ${action.type === "LOG" ? "text-muted-foreground text-xs" : ""}`}
              >
                <span className="text-xs text-muted-foreground mr-2 inline-block w-20">
                  {action.timestamp ? formatTime(action.timestamp) : ""}
                </span>
                {formatAction(action)}
              </li>
            ))}
          </ul>
        )}
      </CardContent>
    </Card>
  );
}

```


### frontend\components\player-actions.tsx

```tsx
// frontend/components/player-actions.tsx
"use client";

import { Button } from "@/components/ui/button";
import { useState } from "react";
import { sendGameAction } from "@/lib/websocket-service";
import { PlayerType } from "@/lib/types";
import RaiseDialog from "@/components/raise-dialog";

interface PlayerActionsProps {
  gameId: string;
  player: PlayerType;
  currentBet: number;
  playerCurrentBet: number;
  pot?: number;
  isPlayerTurn: boolean;
}

export default function PlayerActions({
  gameId,
  player,
  currentBet,
  playerCurrentBet = 0,
  pot = 0,
  isPlayerTurn = false,
}: PlayerActionsProps) {
  const [raiseDialogOpen, setRaiseDialogOpen] = useState(false);

  // Calculate call amount as difference between current table bet and what the player has already contributed
  const callAmount = currentBet - playerCurrentBet;
  const canCheck = callAmount === 0;

  const handleFold = () => {
    if (!isPlayerTurn) return;

    sendGameAction(gameId, {
      playerId: player.id,
      playerName: player.name,
      type: "FOLD",
    });
  };

  const handleCheck = () => {
    if (!isPlayerTurn) return;

    sendGameAction(gameId, {
      playerId: player.id,
      playerName: player.name,
      type: "CHECK",
    });
  };

  const handleCall = () => {
    if (!isPlayerTurn) return;

    sendGameAction(gameId, {
      playerId: player.id,
      playerName: player.name,
      type: "CALL",
      amount: callAmount,
    });
  };

  const handleBet = (amount: number) => {
    if (!isPlayerTurn) return;

    if (amount <= 0 || amount > player.chips) return;

    sendGameAction(gameId, {
      playerId: player.id,
      playerName: player.name,
      type: "BET",
      amount: amount,
    });
  };

  const handleRaise = (amount: number) => {
    if (!isPlayerTurn) return;

    if (amount <= 0) {
      return;
    }
    if (amount + callAmount > player.chips) {
      return;
    }

    sendGameAction(gameId, {
      playerId: player.id,
      playerName: player.name,
      type: "RAISE",
      amount: amount,
    });
  };

  return (
    <div
      className={`p-4 border rounded-md ${!isPlayerTurn ? "opacity-70" : ""}`}
    >
      <div className="flex justify-between items-center mb-3">
        <span className="font-semibold">Actions</span>
        <div className="flex text-sm">
          <span className="mr-4">Current Bet: {currentBet}</span>
          <span className="mr-4">Your Bet: {playerCurrentBet}</span>
          <span>Your Chips: {player.chips}</span>
        </div>
      </div>

      <div className="grid grid-cols-3 gap-2">
        <Button
          onClick={handleFold}
          disabled={player.folded || !isPlayerTurn}
          variant="secondary"
          className="bg-zinc-900 hover:bg-zinc-800"
        >
          Fold
        </Button>

        {canCheck ? (
          <Button
            onClick={handleCheck}
            disabled={player.folded || !isPlayerTurn}
          >
            Check
          </Button>
        ) : (
          <Button
            onClick={handleCall}
            disabled={
              player.folded || !isPlayerTurn || callAmount > player.chips
            }
          >
            Call ({callAmount})
          </Button>
        )}

        <Button
          onClick={() => setRaiseDialogOpen(true)}
          disabled={
            player.folded ||
            !isPlayerTurn ||
            (currentBet > 0 && callAmount >= player.chips)
          }
        >
          {currentBet === 0 ? "Bet" : "Raise"}
        </Button>
      </div>

      <RaiseDialog
        isOpen={raiseDialogOpen}
        onClose={() => setRaiseDialogOpen(false)}
        onRaise={currentBet === 0 ? handleBet : handleRaise}
        currentBet={currentBet}
        pot={pot}
        playerChips={player.chips}
      />
    </div>
  );
}

```


### frontend\components\player-hand.tsx

```tsx
"use client";

import { PlayerType } from "@/lib/types";
import { Card } from "@/components/ui/card";
import PlayingCard from "./playing-card";

interface PlayerHandProps {
  player: PlayerType;
  isCurrentPlayer?: boolean;
  isPlayer?: boolean;
  showCards?: boolean;
  position?: string;
  isWinner?: boolean;
}

export default function PlayerHand({
  player,
  isCurrentPlayer = false,
  position = "",
  showCards = false,
  isWinner = false,
  isPlayer = false,
}: PlayerHandProps) {
  // Helper function to cap name at 16 characters
  const getDisplayName = () => {
    const name = isPlayer ? "YOU" : player.name;
    return name.length > 16 ? name.slice(0, 16) + "..." : name;
  };

  // Function to display the player's status/last action
  const getPlayerStatus = () => {
    if (player.folded) {
      return "Folded";
    }

    if (isCurrentPlayer) {
      return "Current Turn";
    }

    // Show last action if available
    if (player.lastAction) {
      switch (player.lastAction) {
        case "CHECK":
          return "Checked";
        case "BET":
          return `Bet ${player.lastActionAmount}`;
        case "CALL":
          return `Called ${player.lastActionAmount}`;
        case "RAISE":
          return `Raised ${player.lastActionAmount}`;
        case "FOLD":
          return "Folded";
        case "SMALL_BLIND":
          return `SB ${player.lastActionAmount}`;
        case "BIG_BLIND":
          return `BB ${player.lastActionAmount}`;
        default:
          return player.lastAction;
      }
    }

    return "";
  };

  const playerStatus = getPlayerStatus();

  return (
    <Card
      className={`p-2 min-h-52 ${isCurrentPlayer ? "border-2 border-primary" : ""} 
                   ${isWinner ? "border-2 border-green-500" : ""}
                   ${player.active ? "" : "opacity-70"} 
                   ${isPlayer ? "bg-muted/30" : ""}`}
    >
      <div className="flex justify-between items-center">
        <p
          title={isPlayer ? "YOU" : player.name}
          className="font-medium truncate max-w-[80px]"
        >
          {getDisplayName()}
        </p>
        {position && (
          <span className="text-xs bg-primary/10 px-2 py-1 rounded">
            {position}
          </span>
        )}
      </div>
      <p className="text-sm">{player.chips} chips</p>

      <div className="flex flex-col">
        {/* Display hand ranking if available and showCards is true */}
        <p className="text-xs text-center mt-1 font-medium bg-secondary/30 rounded py-1 px-2 text-wrap min-h-[2.5rem] flex items-center justify-center">
          {player.handRanking && (showCards || isPlayer)
            ? player.handRanking
            : "Unknown"}
        </p>

        {/* Player's cards if available */}
        <div className="mt-2 flex justify-center gap-1">
          {player.hand && player.hand.cards && player.hand.cards.length > 0 ? (
            // If player has cards, map and display them
            player.hand.cards.map((card, index) => (
              <PlayingCard
                key={index}
                card={card}
                faceDown={!showCards && !isPlayer}
              />
            ))
          ) : (
            // If player doesn't have cards yet, show 2 hidden placeholders
            <>
              <PlayingCard hidden />
              <PlayingCard hidden />
            </>
          )}

          {/* If player has only 1 card, add a second placeholder */}
          {player.hand &&
            player.hand.cards &&
            player.hand.cards.length === 1 && <PlayingCard hidden />}
        </div>

        {/* Status indicators */}
        <div className="flex justify-center gap-1 mt-1">
          {playerStatus && (
            <span
              className={`text-xs px-2 py-1 rounded ${
                playerStatus === "Current Turn"
                  ? "bg-primary/20"
                  : playerStatus === "Folded"
                    ? "text-muted-foreground"
                    : "bg-secondary/30"
              }`}
            >
              {playerStatus}
            </span>
          )}
        </div>
      </div>
    </Card>
  );
}

```


### frontend\components\player-view.tsx

```tsx
// frontend/components/player-view.tsx
"use client";

import { useGameContext } from "@/lib/game-context";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import PlayerHand from "@/components/player-hand";
import CommunityCards from "@/components/community-cards";
import PlayerActions from "@/components/player-actions";
import AIAdvisor from "@/components/ai-advisor";
import { getPokerPosition } from "@/lib/utils";

interface PlayerViewProps {
  gameId: string;
}

export default function PlayerView({ gameId }: PlayerViewProps) {
  console.log("Rendering PlayerView");
  const { gameRoom, userRole } = useGameContext();

  if (!gameRoom) return <p>Loading player view...</p>;
  if (!userRole?.playerId) return <p>Error: Player ID not found</p>;

  // Find current player by ID
  const currentPlayer = gameRoom.players.find(
    (p) => p.id === userRole.playerId,
  );

  if (!currentPlayer) {
    return <p>Error: Could not find your player information</p>;
  }

  // Check if it's current player's turn
  const isPlayerTurn =
    !gameRoom.waitingForCards &&
    gameRoom.currentPlayerIndex >= 0 &&
    gameRoom.players.length > gameRoom.currentPlayerIndex &&
    gameRoom.players[gameRoom.currentPlayerIndex].id === currentPlayer.id;

  // Get states needed for betting
  const currentBet = gameRoom.currentBet || 0;
  const playerBet = gameRoom.bets ? gameRoom.bets[currentPlayer.id] || 0 : 0;
  const pot = gameRoom.pot || 0;

  // Get game state information
  const isGameActive = ["PREFLOP", "FLOP", "TURN", "RIVER"].includes(
    gameRoom.gameState,
  );

  return (
    <div className="w-full max-w-4xl">
      <Card className="mb-6">
        <CardHeader>
          <CardTitle className="flex justify-between items-center">
            <span>Game Room: {gameId}</span>
          </CardTitle>
        </CardHeader>
        <CardContent>
          <div className="flex flex-col space-y-4">
            {/* Other players */}
            <div className="grid grid-cols-1 md:grid-cols-3 lg:grid-cols-5 gap-4 overflow-x-auto whitespace-nowrap">
              {gameRoom.players.map((player, index) => {
                const position = getPokerPosition(
                  index,
                  gameRoom.players.length,
                  gameRoom.smallBlindPosition,
                );

                // Check if this player is a winner
                const isWinner =
                  gameRoom.winnerIds && gameRoom.winnerIds.includes(player.id);

                return (
                  <PlayerHand
                    key={player.id}
                    player={player}
                    isCurrentPlayer={
                      gameRoom.currentPlayerIndex === index &&
                      !gameRoom.waitingForCards &&
                      gameRoom.gameState != "SHOWDOWN"
                    }
                    position={position}
                    showCards={
                      gameRoom.gameState === "SHOWDOWN" && !player.folded
                    }
                    isWinner={isWinner}
                    isPlayer={userRole.playerId === player.id}
                  />
                );
              })}
            </div>

            {/* Community cards */}
            <CommunityCards gameRoom={gameRoom} />

            {/* Player actions - Always rendered but disabled when not player's turn */}
            {currentPlayer.online && isGameActive && (
              <PlayerActions
                gameId={gameId}
                player={currentPlayer}
                currentBet={currentBet}
                playerCurrentBet={playerBet}
                pot={pot}
                isPlayerTurn={isPlayerTurn}
              />
            )}

            {/* AI Advisor component */}
            {currentPlayer.online && isGameActive && (
              <AIAdvisor
                gameRoom={gameRoom}
                player={currentPlayer}
                isPlayerTurn={isPlayerTurn}
              />
            )}
          </div>
        </CardContent>
      </Card>
    </div>
  );
}

```


### frontend\components\playing-card.tsx

```tsx
// frontend/components/playing-card.tsx
"use client";

import { CardType } from "@/lib/types";

interface PlayingCardProps {
  card?: CardType;
  hidden?: boolean;
  faceDown?: boolean;
}

export default function PlayingCard({
  card,
  hidden = false,
  faceDown = false,
}: PlayingCardProps) {
  // If card is hidden or not provided
  if (hidden || !card) {
    return (
      <div className="border w-14 h-20 rounded-lg flex items-center justify-center bg-primary/20"></div>
    );
  }

  // If card should be shown face down
  if (faceDown) {
    return (
      <div className="border w-14 h-20 rounded-lg flex items-center justify-center bg-secondary/40"></div>
    );
  }

  // Determine color based on suit
  const isRed = card.suit === "HEARTS" || card.suit === "DIAMONDS";

  // Get readable rank name
  const getRankDisplay = (rank: string) => {
    switch (rank) {
      case "ACE":
        return "A";
      case "KING":
        return "K";
      case "QUEEN":
        return "Q";
      case "JACK":
        return "J";
      case "TEN":
        return "10";
      case "NINE":
        return "9";
      case "EIGHT":
        return "8";
      case "SEVEN":
        return "7";
      case "SIX":
        return "6";
      case "FIVE":
        return "5";
      case "FOUR":
        return "4";
      case "THREE":
        return "3";
      case "TWO":
        return "2";
      default:
        return "?";
    }
  };

  // Get suit symbol
  const getSuitSymbol = (suit: string) => {
    switch (suit) {
      case "HEARTS":
        return "♥";
      case "DIAMONDS":
        return "♦";
      case "CLUBS":
        return "♣";
      case "SPADES":
        return "♠";
      default:
        return "";
    }
  };

  return (
    <div
      className={`border w-14 h-20 rounded-lg flex flex-col justify-between py-2 px-3 bg-white ${isRed ? "text-red-500" : "text-black"}`}
    >
      <div className={"text-2xl"}>{getRankDisplay(card.rank)}</div>
      <div className={"text-2xl"}>{getSuitSymbol(card.suit)}</div>
    </div>
  );
}

```


### frontend\components\raise-dialog.tsx

```tsx
// frontend/components/raise-dialog.tsx
"use client";

import { useRef, useState } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from "@/components/ui/dialog";

interface RaiseDialogProps {
  isOpen: boolean;
  onClose: () => void;
  onRaise: (amount: number) => void;
  currentBet: number;
  pot: number;
  playerChips: number;
}

export default function RaiseDialog({
  isOpen,
  onClose,
  onRaise,
  pot,
  playerChips,
}: RaiseDialogProps) {
  const [customAmount, setCustomAmount] = useState<number>(0);
  const inputRef = useRef<HTMLInputElement>(null);

  const thirdPot = Math.floor(pot * 0.33);
  const halfPot = Math.floor(pot * 0.5);
  const fullPot = pot;

  const handleRaiseOption = (amount: number) => {
    onRaise(amount);
    onClose();
  };

  const handleCustomRaise = () => {
    if (customAmount > 0 && customAmount <= playerChips) {
      onRaise(customAmount);
      onClose();
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={(open) => !open && onClose()}>
      <DialogContent className={"max-w-xs rounded-lg top-1/4"}>
        <DialogHeader>
          <DialogTitle>Select Raise Amount</DialogTitle>
        </DialogHeader>

        <div className="grid grid-cols-2 gap-2 py-4">
          <Button
            onClick={() => handleRaiseOption(thirdPot)}
            disabled={thirdPot > playerChips}
          >
            33% Pot ({thirdPot})
          </Button>

          <Button
            onClick={() => handleRaiseOption(halfPot)}
            disabled={halfPot > playerChips}
          >
            50% Pot ({halfPot})
          </Button>

          <Button
            onClick={() => handleRaiseOption(fullPot)}
            disabled={fullPot > playerChips}
          >
            100% Pot ({fullPot})
          </Button>

          <Button
            onClick={() => handleRaiseOption(playerChips)}
            variant="secondary"
          >
            All In ({playerChips})
          </Button>
        </div>

        <div className="flex gap-2">
          <Input
            ref={inputRef}
            type="number"
            min={1}
            max={playerChips}
            value={customAmount}
            onChange={(e) => setCustomAmount(Number(e.target.value))}
            placeholder="Custom amount"
            className="w-full"
          />
          <Button
            onClick={handleCustomRaise}
            disabled={customAmount <= 0 || customAmount > playerChips}
          >
            Raise
          </Button>
        </div>

        <DialogFooter>
          <Button onClick={onClose} variant="outline">
            Cancel
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

```
